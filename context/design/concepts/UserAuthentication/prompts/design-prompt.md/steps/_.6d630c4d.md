---
timestamp: 'Thu Oct 16 2025 15:22:49 GMT-0400 (Eastern Daylight Time)'
parent: '[[../20251016_152249.f5c7d9d7.md]]'
content_id: 6d630c4dc3beef342578375707a87cf6cbc8548999e6668c0d305b0f1289d374
---

# UserAuthentication â€” Design Changes & Issues

This document outlines the evolution of the `UserAuthentication` concept from its initial representations in Assignment 2 (`User` and `EmailAuth`) to its current, consolidated form. It details the reasoning behind these changes, connecting them directly to the feedback received and broader concept design principles.

## Summary of Changes

The primary change is the **consolidation of user account management and email verification functionality** into a single `UserAuthentication` concept.

Key specific changes include:

1. **Consolidated Authentication and Verification**: Merged the authentication-related aspects of the original `User` concept with the `EmailAuth` concept. The new `UserAuthentication` now internally manages user identity (via a generic `User` type parameter `[User]`), account credentials, and the full email verification lifecycle. It no longer includes non-authentication-specific user attributes like `firstName` or `lastName`.
2. **Refined Status Model**: The `status` for `UserAccounts` evolved to `UNVERIFIED`, `VERIFIED`, `DEACTIVATED`, explicitly dictating that only `VERIFIED` users can `login`.
3. **Integrated Email Verification**: All aspects of email verification (code generation, expiry, matching, and account status update) are now internal to `UserAuthentication`, including the `VerificationCodes` state and associated actions.
4. **Password Hashing**: Includes `passwordHashed` in state for security.
5. **Explicit Error Handling**: Actions define explicit success (`(user: User)`) and error (`(error: String)`) return signatures.
6. **Reactivation Flow**: A deactivated user reactivates to an `UNVERIFIED` state, requiring re-verification.
7. **System Cleanup Action**: Introduced `system cleanExpiredCodes` to manage expired verification codes.

## Rationale (Connect to Feedback)

The changes were directly inspired by the Assignment 2 feedback, which highlighted issues with modularity, separation of concerns, and concept independence:

* **"User is a generic type and extremely standard, so in the future no need to define it unless there is really special functionality for your app."**
  * **Response**: By using a generic `User` type `[User]` and shedding non-authentication attributes (e.g., `firstName`, `lastName`), `UserAuthentication` now strictly focuses on authentication-related data (`email`, `passwordHashed`, `status`). This directly addresses the feedback by making the concept more generic, reusable, and aligned with the "small and specific set of info and actions" principle, deferring broader user profile details to other concepts.

* **"Typically email auth is also not its own concept (remember the token example from the psets?)."**
  * **Response**: The feedback correctly identified that `EmailAuth` was not a truly independent, user-facing concept. Similar to the pset's Exercise 2, which demonstrated extending `PasswordAuthentication` to include token-based email confirmation *within* the same concept, `EmailAuth` functions as a *mechanism* or *internal process* to fulfill the larger purpose of `UserAuthentication` (account verification). It lacks a distinct "well-defined and intelligible purpose" that stands alone from managing user accounts and credentials. Merging `EmailAuth` into `UserAuthentication` ensures the latter is complete in managing its entire authentication lifecycle, including necessary verification steps, without relying on a separate, dependent concept. This reduces conceptual fragmentation and tightens the focus on authentication as a single, modular unit.

* **"We want to maintain modularity and separation of concerns such that each concept handles only a very small and specific set of info and actions..."**
  * **Response**: Consolidating `User`'s authentication concerns with `EmailAuth` allowed `UserAuthentication` to become a cohesive, self-contained unit. It now *solely* handles account creation, credential management, and email verification, creating a clear boundary from other user-related functionality (e.g., profiles, roles). This significantly enhances modularity and the separation of concerns, as each concept now addresses a truly distinct aspect.

## Design Decisions

1. **Merging `EmailAuth` into `UserAuthentication`**:
   * **Why**: The `EmailAuth` concept lacked true independence, acting more as an internal mechanism for account activation rather than a standalone user-facing service. Similar to how the psets illustrated extending `PasswordAuthentication` with an internal token-based confirmation, `EmailAuth`'s functionality is inherently part of the authentication process. Merging it ensures `UserAuthentication` provides *complete functionality* for its domain (authentication) by encapsulating the entire account lifecycle, including verification. This removes the prior problematic coupling and aligns with the concept design principle of independence and completeness.
   * **Result**: `VerificationCodes` state and all email verification actions (`sendVerificationCode`, `verifyCode`, `revokeVerification`) are now internal to `UserAuthentication`, streamlining the authentication flow and eliminating cross-concept dependencies for this core functionality.

2. **Refined Status Model (`UNVERIFIED`, `VERIFIED`, `DEACTIVATED`)**:
   * **Why**: The `PENDING`/`REGISTERED` distinction in the original `User` concept was ambiguous regarding login eligibility. The new model clearly defines `VERIFIED` as the explicit prerequisite for `login`, providing a more precise and robust state machine for account activation and security. The `DEACTIVATED` state ensures accounts are marked as unusable until explicit reactivation.
   * **Result**: Enhanced clarity in user lifecycle management and improved security (e.g., an unverified user cannot log in).

3. **Use of Generic `User` Type**:
   * **Why**: To prevent `UserAuthentication` from becoming a monolithic "God object" handling all aspects of a "user." By accepting a generic `User` type parameter, `UserAuthentication` focuses purely on *authenticating* an identity, without conflating it with profile details (e.g., `firstName`, `lastName`) or other attributes. This promotes reusability across diverse applications.
   * **Result**: `UserAuthentication` is more focused, adheres better to separation of concerns, and is more reusable. Other concepts (e.g., `UserProfile`, `UserRoles`) would manage other aspects of a user, using synchronizations to coordinate with `UserAuthentication` as needed.

## Issues Encountered

1. **Status Model Complexity (Trade-off)**: The `DEACTIVATED` state currently requires reactivation to an `UNVERIFIED` status, necessitating re-verification. This prioritizes security (re-establishing email ownership after inactivity) over potential user experience friction, a deliberate trade-off. An alternative allowing direct return to `VERIFIED` was considered but deemed less secure.

2. **Code Expiry and Cleanup**: The `system cleanExpiredCodes` action, necessary for managing `VerificationCodes` expiry, implies an external operational dependency (e.g., a background job). While crucial for state management, it's an implementation detail that needs consideration beyond the concept definition.

3. **Definition of "User" Across Concepts (Ongoing Consideration)**: While `UserAuthentication` uses a generic `User` type for modularity, defining a comprehensive "User" across an application requires coordinating information from various specialized concepts (e.g., `UserProfile`, `UserSettings`) via syncs. This is a positive trade-off for concept independence but necessitates careful orchestration for a complete user view.

These changes collectively enhance the clarity, modularity, and reusability of `UserAuthentication`, making it a more robust and compliant concept design in line with the specified principles.
