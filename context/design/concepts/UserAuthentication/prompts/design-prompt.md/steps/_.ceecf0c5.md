---
timestamp: 'Thu Oct 16 2025 15:08:11 GMT-0400 (Eastern Daylight Time)'
parent: '[[../20251016_150811.1c3ee28b.md]]'
content_id: ceecf0c51bf70b23961c9b88c97d7775e34004a0a79f58eb5b24de908251cd26
---

# UserAuthentication â€” Design Changes & Issues

This document outlines the evolution of the `UserAuthentication` concept from its initial representations in Assignment 2 (`User` and `EmailAuth`) to its current, consolidated form. It details the reasoning behind these changes, connecting them directly to the feedback received and broader concept design principles.

## Summary of Changes

The primary change is the **consolidation of user account management and email verification functionality** into a single `UserAuthentication` concept.

Key specific changes include:

1. **Merging `User` and `EmailAuth`**: The original `User` concept (handling identity, names, status) and `EmailAuth` concept (handling verification codes) have been combined.
2. **Generic `User` Type**: The concept now accepts a generic `User` type parameter (`[User]`) for user identifiers, rather than defining internal user-specific attributes like `firstName` and `lastName`.
3. **Refined Status Model**: The `status` field for `UserAccounts` evolved from `PENDING`, `REGISTERED`, `DEACTIVATED` to `UNVERIFIED`, `VERIFIED`, `DEACTIVATED`, with explicit rules for `login` only for `VERIFIED` users.
4. **Integrated Email Verification**: All aspects of email verification (code generation, expiry, matching, and status update) are now internal to `UserAuthentication`, including `VerificationCodes` as part of its state and corresponding actions.
5. **Password Hashing**: Explicit mention of `passwordHashed` in the state for security.
6. **Explicit Error Handling**: Actions like `registerUser` and `login` now define separate return signatures for success (e.g., `(user: User)`) and failure (e.g., `(error: String)`).
7. **Reactivation Flow**: A deactivated user reactivates to an `UNVERIFIED` state, requiring re-verification.
8. **System Cleanup Action**: Introduction of `system cleanExpiredCodes` for managing transient state.

## Rationale (Connect to Feedback)

The changes were directly inspired by the Assignment 2 feedback, which highlighted issues with modularity, separation of concerns, and concept independence:

* **"User is a generic type and extremely standard, so in the future no need to define it unless there is really special functionality for your app."**
  * **Response**: The `UserAuthentication` concept now uses a generic `User` type `[User]` to refer to user identities. It no longer attempts to define `firstName` or `lastName` (which would fall under a `UserProfile` concept) but focuses solely on authentication-related user properties (`email`, `passwordHashed`, `status`). This aligns `UserAuthentication` with the principle of focusing on "a very small and specific set of info and actions."
* **"Typically email auth is also not its own concept (remember the token example from the psets?)."**
  * **Response**: The `EmailAuth` concept was merged directly into `UserAuthentication`. This eliminates a separate, highly coupled concept and ensures `UserAuthentication` is complete in managing its entire lifecycle, including verification.
* **"We want to maintain modularity and separation of concerns such that each concept handles only a very small and specific set of info and actions..."**
  * **Response**: By combining `User` (specifically its authentication aspects) and `EmailAuth`, `UserAuthentication` now represents a cohesive, self-contained unit responsible *solely* for account creation, credential management, and email-based activation/verification. It has a well-defined boundary, distinguishing it from other user-related concerns like profiles, roles, or permissions, which would be handled by separate concepts. This significantly improves separation of concerns.

## Design Decisions

1. **Merging `EmailAuth` into `UserAuthentication`**:
   * **Why**: The original `EmailAuth` concept suffered from a lack of concept independence, as it explicitly referenced `User` in its state. Email verification is also intrinsically tied to the lifecycle and security status of a user account. Merging these two aspects creates a single, more coherent concept that fully encapsulates the *authentication* process, from registration to verification and login. This better aligns with the "Completeness of functionality" principle for a specific domain (authentication).
   * **Result**: The `VerificationCodes` state and associated actions (`sendVerificationCode`, `verifyCode`, `revokeVerification`) are now internal to `UserAuthentication`, eliminating cross-concept dependencies for this core flow.

2. **Refined Status Model (`UNVERIFIED`, `VERIFIED`, `DEACTIVATED`)**:
   * **Why**: The `PENDING`/`REGISTERED` distinction in the original `User` concept was less precise regarding login eligibility. The new model clearly defines `VERIFIED` as the prerequisite for `login`, providing a clearer state machine for account activation. The `DEACTIVATED` state ensures accounts are marked as unusable until explicit reactivation.
   * **Result**: Enhanced clarity in user lifecycle management and security (e.g., an unverified user cannot log in).

3. **Use of Generic `User` Type**:
   * **Why**: To prevent `UserAuthentication` from becoming a monolithic "God object" for all things "user". By using a generic `User` type, `UserAuthentication` focuses purely on *authenticating* an identity, without conflating it with profile details (e.g., `firstName`, `lastName`) or other attributes.
   * **Result**: `UserAuthentication` is more reusable and adheres better to separation of concerns. Other concepts (e.g., `UserProfile`, `UserRoles`) would manage other aspects of a user, using syncs to coordinate with `UserAuthentication` as needed.

## Issues Encountered

1. **Status Model Complexity (Trade-off)**: While the `UNVERIFIED`/`VERIFIED` model is clearer, the `DEACTIVATED` state adds a layer of complexity to reactivation. Specifically, reactivating an account returns it to `UNVERIFIED` status, requiring the user to re-verify their email.
   * **Trade-off**: This choice prioritizes security (ensuring email ownership after a period of inactivity) over potential user experience friction (requiring an additional step for reactivation). A design choice could have been to allow `DEACTIVATED` to return to `VERIFIED` if the email was previously verified, but the current approach enforces a more robust security posture.

2. **Code Expiry and Cleanup**: The `VerificationCodes` have an `expiry` time, necessitating a `system cleanExpiredCodes` action.
   * **Issue**: While part of the concept, the `system` action implies an external mechanism (e.g., a background job or cron service) to trigger this cleanup. This isn't strictly an *issue* with the concept definition itself but highlights an operational dependency that needs to be considered during implementation.

3. **Definition of "User" (Ongoing Consideration)**: While `UserAuthentication` now uses a generic `User` type, the overall system still needs a clear understanding of what a "User" is across different concepts.
   * **Trade-off**: The current approach pushes the responsibility of defining rich user attributes (like name, address, preferences) to other specialized concepts (e.g., `UserProfile`, `UserSettings`). This is a *positive* trade-off for modularity but means a full "user profile" view for an application would require coordinating multiple concepts via syncs.

These changes collectively enhance the clarity, modularity, and reusability of `UserAuthentication`, making it a more robust and compliant concept design.
