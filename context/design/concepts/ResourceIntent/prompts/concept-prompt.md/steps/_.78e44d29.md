---
timestamp: 'Tue Oct 21 2025 13:58:40 GMT-0400 (Eastern Daylight Time)'
parent: '[[../20251021_135840.26987d9e.md]]'
content_id: 78e44d29ae887911e117cc1e4b04c934b7d83c945907655e6c569685de849c41
---

# Iterated ResourceIntent Concept

## Overview of Alignment with Concept Design Principles

The `ResourceIntent` concept is a prime example of effective concept design, particularly in its emphasis on independence and separation of concerns.

1. **Reusable Unit of User-Facing Functionality:** The purpose—associating resources with configurable labels—is broadly applicable across many applications. While the concept itself provides a backend service, its functionality directly enables user-facing features (e.g., filtering lists by 'featured' intent, categorizing content). The actions provide a clear protocol for managing these labels.
2. **Maintains its Own State:** The concept clearly defines its internal state through `IntentDefinitions` and `IntentEntries`. This state is precisely tailored to its purpose: tracking available intent labels and the current intent for each resource. It includes no extraneous information, adhering to the "no richer than it need be" principle.
3. **Interacts Through Atomic Actions:** Each action (e.g., `defineIntent`, `setIntent`, `getIntent`) is atomic, focused, and directly manipulates or queries the concept's state. These actions form a well-defined API.
4. **Mutual Independence:** This is a cornerstone of the `ResourceIntent` design.
   * **Polymorphism:** The use of a generic `ResourceID` type parameter ensures the concept makes no assumptions about the nature or content of the resources it labels. It simply requires a unique identifier, allowing it to apply to any type of resource (posts, users, comments, etc.) without coupling to their specific schemas.
   * **No Cross-Concept References:** The concept explicitly states in its principles: "This concept does not depend on or write to other concepts." This is fully reflected in its state and actions, which operate solely on internal data.
   * **Standalone Understandability:** One can fully grasp the function and behavior of `ResourceIntent` without any knowledge of other concepts in an application.
5. **Separation of Concerns:** The principles explicitly limit the concept's scope: "This is purely declarative; no lifecycle, timing, ownership, or matching logic is implied." This clearly delineates its responsibility to *only* manage resource labels, leaving the interpretation and application of these labels to other concepts via synchronizations. This prevents the conflation of "labeling" with "what to do with labels."
6. **Completeness of Functionality:** All actions required to define intents, set them on resources, and retrieve them are fully contained within the `ResourceIntent` concept. It does not rely on "making calls" to external concepts to fulfill its core purpose. For example, `defineIntent` adds a definition directly; it doesn't ask another "Vocabulary" concept to handle it.
7. **Composition by Synchronization:** While not part of the concept's definition itself, the design of `ResourceIntent` perfectly enables composition via syncs. Any logic that *reacts* to a resource having a particular intent (e.g., "when a Post's intent is 'Featured', then display it on the homepage") would be implemented as a synchronization rule, adhering to the prescribed composition mechanism.

## Refined Concept Definition

```
concept: ResourceIntent<ResourceID>

* purpose: Associate any resource, identified by a generic ResourceID, with a single, application-defined intent label drawn from a configurable vocabulary. This is purely declarative; no lifecycle, timing, ownership, or matching logic is implied by this concept.
* principle:
  * Intent is a simple, singular label on a resource.
  * The set of valid intent labels is defined and managed exclusively within this concept.
  * A resource can have at most one intent label at any given time.
  * This concept is entirely independent; it does not depend on or directly interact with the state or actions of any other concepts.
  * ResourceID is a generic identifier type; this concept makes no assumptions about the underlying nature or properties of the resources themselves, beyond their unique identification.

state:

* a set of IntentDefinitions, each with:
  * intentName String
* a set of IntentEntries, each with:
  * resource ResourceID // A unique identifier for the external resource
  * intent String // Must reference an existing IntentDefinition.intentName

actions:

* defineIntent(intentName: String): Empty
  * purpose: Establishes a new valid intent label within the concept's vocabulary.
  * requires:
    * No IntentDefinition currently exists with the given intentName.
  * effects:
    * Adds `intentName` to the `IntentDefinitions` set.

* undefineIntent(intentName: String): Empty
  * purpose: Removes an existing intent label from the concept's vocabulary.
  * requires:
    * An IntentDefinition exists with the given intentName.
    * No IntentEntry currently uses the given intentName.
  * effects:
    * Removes `intentName` from the `IntentDefinitions` set.

* setIntent(resource: ResourceID, intent: String): Empty
  * purpose: Assigns a specified intent label to a resource.
  * requires:
    * The `intent` string must be defined in `IntentDefinitions`.
  * effects:
    * If an `IntentEntry` already exists for `resource`, its `intent` is updated to the new value.
    * If no `IntentEntry` exists for `resource`, a new `IntentEntry` is created, associating `resource` with `intent`.

* clearIntent(resource: ResourceID): Empty
  * purpose: Removes any assigned intent label from a resource.
  * requires:
    * An `IntentEntry` currently exists for the specified `resource`.
  * effects:
    * Removes the `IntentEntry` for `resource` from the set.

* getIntent(resource: ResourceID): { resource: ResourceID, intent: String } | Null
  * purpose: Retrieves the current intent label for a given resource.
  * requires:
    * true (This is a read-only query and always permissible.)
  * effects:
    * Returns the `IntentEntry` for `resource` if it exists, otherwise returns `Null`.

* listIntents(): String[]
  * purpose: Provides a list of all currently defined intent labels.
  * requires:
    * true (This is a read-only query and always permissible.)
  * effects:
    * Returns an array of all `intentName` values from `IntentDefinitions`.

* listResourcesByIntent(intent: String): ResourceID[]
  * purpose: Retrieves all resources currently labeled with a specific intent.
  * requires:
    * The `intent` string must be defined in `IntentDefinitions`.
  * effects:
    * Returns an array of `ResourceID`s for all `IntentEntries` whose `intent` matches the given string.
```
